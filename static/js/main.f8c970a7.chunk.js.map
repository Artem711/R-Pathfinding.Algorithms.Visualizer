{"version":3,"sources":["Helpers/Functions/index.ts","Helpers/Algorithms/dijkstra.ts","Components/Grid/index.tsx","Components/Node/index.tsx","App.tsx","Redux/store.ts","index.tsx"],"names":["memoComparison","prevProps","nextProps","shallowEqual","Dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","row","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","isWall","Infinity","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","unvisitedNeighbors","neighbors","column","filter","neighbor","getUnvisitedNeighbors","previousNode","Grid","props","useState","setGrid","mouseIsPressed","setMouseIsPressed","useEffect","getInitialGrid","handleMouseDown","newGrid","getNewGridWithWallToggled","handleMouseEnter","handleMouseUp","animateShortestPath","nodesInShortestPathOrder","i","setTimeout","doc","document","getElementById","className","visualizeDijkstra","animateDijkstra","currentNode","unshift","getNodesInShortestPathOrder","onClick","map","rowIdx","nodeIdx","isFinish","isStart","onMouseDown","onMouseEnter","onMouseUp","React","memo","currentRow","createNode","slice","newNode","Node","extraClassName","id","App","store","configureStore","reducer","ReactDOM","render"],"mappings":"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","file":"static/js/main.f8c970a7.chunk.js","sourcesContent":["import {shallowEqual} from 'react-redux';\n\nexport const memoComparison = (prevProps: any, nextProps: any) => {\n  return shallowEqual(prevProps, nextProps);\n};\n","import {GridType, NodeType} from 'Redux/types';\n\n// Performs Dijkstra's algorithm; returns *all* nodes in the order\n// in which they were visited. Also makes nodes point back to their\n// previous node, effectively allowing us to compute the shortest path\n// by backtracking from the finish node.\nexport function Dijkstra(\n  grid: GridType,\n  startNode: NodeType,\n  finishNode: NodeType,\n) {\n  const visitedNodesInOrder = [];\n  startNode.distance = 0;\n  const unvisitedNodes = getAllNodes(grid);\n  while (!!unvisitedNodes.length) {\n    sortNodesByDistance(unvisitedNodes);\n    const closestNode = unvisitedNodes.shift();\n    if (closestNode) {\n      // If we encounter a wall, we skip it.\n      if (closestNode.isWall) continue;\n      // If the closest node is at a distance of infinity,\n      // we must be trapped and should therefore stop.\n      if (closestNode.distance === Infinity) return visitedNodesInOrder;\n      closestNode.isVisited = true;\n      visitedNodesInOrder.push(closestNode);\n      if (closestNode === finishNode) return visitedNodesInOrder;\n      updateUnvisitedNeighbors(closestNode, grid);\n    }\n  }\n}\n\nfunction sortNodesByDistance(unvisitedNodes: Array<NodeType>) {\n  unvisitedNodes.sort(\n    (nodeA: NodeType, nodeB: NodeType) => nodeA.distance - nodeB.distance,\n  );\n}\n\nfunction updateUnvisitedNeighbors(node: NodeType, grid: GridType) {\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\n  for (const neighbor of unvisitedNeighbors) {\n    neighbor.distance = node.distance + 1;\n    neighbor.previousNode = node;\n  }\n}\n\nfunction getUnvisitedNeighbors(node: NodeType, grid: GridType) {\n  const neighbors = [];\n  const {column, row} = node;\n  if (row > 0) neighbors.push(grid[row - 1][column]);\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][column]);\n  if (column > 0) neighbors.push(grid[row][column - 1]);\n  if (column < grid[0].length - 1) neighbors.push(grid[row][column + 1]);\n  return neighbors.filter(neighbor => !neighbor.isVisited);\n}\n\nfunction getAllNodes(grid: GridType) {\n  const nodes = [];\n  for (const row of grid) {\n    for (const node of row) {\n      nodes.push(node);\n    }\n  }\n  return nodes;\n}\n\n// Backtracks from the finishNode to find the shortest path.\n// Only works when called *after* the dijkstra method above.\nexport function getNodesInShortestPathOrder(finishNode: NodeType) {\n  const nodesInShortestPathOrder = [];\n  let currentNode: NodeType | null = finishNode;\n  while (currentNode !== null) {\n    nodesInShortestPathOrder.unshift(currentNode);\n    currentNode = currentNode.previousNode;\n  }\n  return nodesInShortestPathOrder;\n}\n","// PLUGINS IMPORTS //\nimport React, {useEffect, useState} from 'react';\n\n// COMPONENTS IMPORTS //\nimport {Node} from 'Components';\nimport {memoComparison} from 'Helpers/Functions';\n\n// EXTRA IMPORTS //\nimport {\n  Dijkstra,\n  getNodesInShortestPathOrder,\n} from 'Helpers/Algorithms/dijkstra';\nimport './Grid.css';\n\n// REDUX IMPORTS //\nimport {GridType, NodeType} from 'Redux/types';\n\n/////////////////////////////////////////////////////////////////////////////\n\nconst START_NODE_ROW = 10;\nconst START_NODE_COL = 15;\nconst FINISH_NODE_ROW = 10;\nconst FINISH_NODE_COL = 35;\n\ninterface PropsType {}\n\nconst Grid: React.FC<PropsType> = props => {\n  const [grid, setGrid] = useState<GridType>([]);\n  const [mouseIsPressed, setMouseIsPressed] = useState<boolean>(false);\n\n  useEffect(() => {\n    const grid = getInitialGrid();\n    setGrid(grid);\n  }, []);\n\n  const handleMouseDown = (row: number, column: number) => {\n    const newGrid = getNewGridWithWallToggled(grid, row, column);\n    setGrid(newGrid);\n    setMouseIsPressed(true);\n  };\n  const handleMouseEnter = (row: number, column: number) => {\n    if (!mouseIsPressed) return;\n    const newGrid = getNewGridWithWallToggled(grid, row, column);\n    setGrid(newGrid);\n  };\n  const handleMouseUp = () => {\n    setMouseIsPressed(false);\n  };\n\n  const animateDijkstra = (\n    visitedNodesInOrder?: Array<NodeType>,\n    nodesInShortestPathOrder?: Array<NodeType>,\n  ) => {\n    if (visitedNodesInOrder && nodesInShortestPathOrder) {\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\n        if (i === visitedNodesInOrder.length) {\n          setTimeout(() => {\n            animateShortestPath(nodesInShortestPathOrder);\n          }, 10 * i);\n          return;\n        }\n        setTimeout(() => {\n          const node = visitedNodesInOrder[i];\n          const doc = document.getElementById(\n            `node-${node.row}-${node.column}`,\n          );\n          if (doc) doc.className = 'node node-visited';\n        }, 10 * i);\n      }\n    }\n  };\n\n  const animateShortestPath = (nodesInShortestPathOrder: Array<NodeType>) => {\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\n      setTimeout(() => {\n        const node = nodesInShortestPathOrder[i];\n        const doc = document.getElementById(`node-${node.row}-${node.column}`);\n        if (doc) doc.className = 'node node-shortest-path';\n      }, 50 * i);\n    }\n  };\n\n  const visualizeDijkstra = () => {\n    const startNode = grid[START_NODE_ROW][START_NODE_COL] as NodeType;\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL] as NodeType;\n    const visitedNodesInOrder = Dijkstra(grid, startNode, finishNode);\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\n    animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\n  };\n\n  return (\n    <>\n      <button onClick={() => visualizeDijkstra()}>\n        Visualize Dijkstra's Algorithm\n      </button>\n      <div className=\"grid\">\n        {grid.map((row, rowIdx) => {\n          return (\n            <div key={rowIdx}>\n              {row.map((node, nodeIdx) => {\n                return (\n                  <Node\n                    key={nodeIdx}\n                    node={node}\n                    isFinish={node.isFinish}\n                    isStart={node.isStart}\n                    onMouseDown={handleMouseDown}\n                    onMouseEnter={handleMouseEnter}\n                    onMouseUp={handleMouseUp}\n                  />\n                );\n              })}\n            </div>\n          );\n        })}\n      </div>\n    </>\n  );\n};\n\nexport default React.memo(Grid, memoComparison);\n\nconst getInitialGrid = (): GridType => {\n  const grid = [];\n  for (let row = 0; row < 20; row++) {\n    const currentRow = [];\n    for (let column = 0; column < 50; column++) {\n      currentRow.push(createNode(column, row));\n    }\n    grid.push(currentRow);\n  }\n  return grid;\n};\n\nconst createNode = (column: number, row: number): NodeType => {\n  return {\n    column,\n    row,\n    isStart: row === START_NODE_ROW && column === START_NODE_COL,\n    isFinish: row === FINISH_NODE_ROW && column === FINISH_NODE_COL,\n    distance: Infinity,\n    isVisited: false,\n    isWall: false,\n    previousNode: null,\n  };\n};\n\nconst getNewGridWithWallToggled = (\n  grid: GridType,\n  row: number,\n  column: number,\n) => {\n  const newGrid = grid.slice();\n  const node = newGrid[row][column];\n  const newNode = {\n    ...node,\n    isWall: !node.isWall,\n  };\n  newGrid[row][column] = newNode;\n  return newGrid;\n};\n","// PLUGINS IMPORTS //\nimport React from 'react';\n\n// COMPONENTS IMPORTS //\nimport {memoComparison} from 'Helpers/Functions';\n\n// EXTRA IMPORTS //\nimport './Node.css';\n\n// REDUX IMPORTS //\nimport {NodeType} from 'Redux/types';\n\n/////////////////////////////////////////////////////////////////////////////\n\ntype VoidNodeMouseHandlerType = (row: number, column: number) => void;\ninterface PropsType {\n  node: NodeType;\n  isFinish: boolean;\n  isStart: boolean;\n  onMouseDown: VoidNodeMouseHandlerType;\n  onMouseEnter: VoidNodeMouseHandlerType;\n  onMouseUp: () => void;\n}\n\nconst Node: React.FC<PropsType> = props => {\n  const extraClassName = props.isFinish\n    ? 'node-finish'\n    : props.isStart\n    ? 'node-start'\n    : props.node.isWall\n    ? 'node-wall'\n    : '';\n\n  return (\n    <div\n      id={`node-${props.node.row}-${props.node.column}`}\n      className={`node ${extraClassName}`}\n      onMouseDown={() => props.onMouseDown(props.node.row, props.node.column)}\n      onMouseEnter={() => props.onMouseEnter(props.node.row, props.node.column)}\n      onMouseUp={() => props.onMouseUp()}></div>\n  );\n};\n\nexport default React.memo(Node, memoComparison);\n","// PLUGINS IMPORTS //\nimport React from 'react';\n\n// COMPONENTS IMPORTS //\nimport {Grid} from 'Components';\n\n// EXTRA IMPORTS //\nimport {memoComparison} from 'Helpers/Functions';\n\n/////////////////////////////////////////////////////////////////////////////\n\ntype PropsType = {};\n\nconst App: React.FC<PropsType> = () => {\n  return (\n    <div>\n      <Grid />\n    </div>\n  );\n};\n\nexport default React.memo(App, memoComparison);\n","import {configureStore} from '@reduxjs/toolkit';\nimport {useDispatch} from 'react-redux';\n\nexport const store = configureStore({\n  reducer: {},\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\n","// PLUGINS IMPORTS //\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\n\n// COMPONENTS IMPORTS //\nimport App from './App';\n\n// EXTRA IMPORTS //\n\n// REDUX IMPORTS //\nimport {Provider} from 'react-redux';\nimport {store} from 'Redux/store';\n\n/////////////////////////////////////////////////////////////////////////////\n\nReactDOM.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}